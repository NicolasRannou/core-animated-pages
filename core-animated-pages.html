<link href="../polymer/polymer.html" rel="import">
<link href="../core-selector/core-selector.html" rel="import">
<link href="../core-style/core-style.html" rel="import">
<link href="../core-transition/core-transition.html" rel="import">

<link href="core-transition-hero.html" rel="import">

<!--

`core-animated-pages` selects one of its children "pages" to show and runs a transition
when switching between them. By default, children are cross faded with each other.

  * The hero element must not be the top-level container of the page.

  * The parent elements of the hero should also be marked "hero"

  * The hero element's children will fade during the transition, unless the child is
    also a hero.

-->
<polymer-element name="core-animated-pages" extends="core-selector" notap attributes="heroDuration transitions defaultTransition">

<template>

  <style>
    :host {
      display: block;
      position: relative;
    }

    polyfill-next-selector { content: ':host > *'; }
    ::content > * {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      visibility: hidden;
      z-index: -1000;
    }

    polyfill-next-selector { content: ':host > .core-selected'; }
    ::content > .core-selected {
      visibility: visible;
      z-index: auto;
    }

    /* Both pages being animated must be visible */
    polyfill-next-selector { content: ':host > [animate]'; }
    ::content > [animate] {
      visibility: visible;
      z-index: auto;
    }
  </style>

  <template repeat="{{transitions}}">
    <core-style ref="{{}}"></core-style>
  </template>

  <shadow></shadow>

</template>

<script>

  Polymer({

    eventDelegates: {
      'core-hero-transitionend': 'transitionEnd',
      'webkitTransitionEnd': 'transitionEnd',
      'transitionEnd': 'transitionEnd'
    },

    publish: {

      /**
       * The duration of the hero transition in milliseconds.
       *
       * @attribute heroDuration
       * @type number
       * @default 1000
       */
      heroDuration: { value: 1000, reflect: true }

    },

    transitions: [],
    defaultTransition: '',

    transitioning: [],

    selected: 0,

    registerCallback: function() {
      this.meta = document.createElement('core-transition');
    },

    defaultTransitionChanged: function(old) {
      if (old) {
        this.classList.remove(old);
      }
      if (this.defaultTransition) {
        this.classList.add(this.defaultTransition);
      }
      console.log(old + ' -> ' + this.defaultTransition);
    },

    getTransition: function(transitionId) {
      return this.meta.byId(transitionId);
    },

    applyTransition: function(src, dst) {
      if (this.transitioning.indexOf(src) === -1) {
        this.transitioning.push(src);
      }
      if (this.transitioning.indexOf(dst) === -1) {
        this.transitioning.push(dst);
      }

      var hero = this.getTransition('core-transition-hero');
      hero.setup(src, dst, this);

      var transitions = [];
      var ts$ = src.querySelectorAll('[transition]');
      for (var i = 0, el; el=ts$[i]; i++) {
        this.setupTransition(transitions, ts);
      }

      var td$ = dst.querySelectorAll('[transition]');
      for (var i = 0, el; el=td$[i]; i++) {
        this.setupTransition(transitions, ts);
      }

      transitions.forEach(function(transition) {
        transition.t.setup(transition.t.el, transition.t.args)
      });

      src.setAttribute('animate', '');
      dst.setAttribute('animate', '');

      getComputedStyle(dst).top;

      hero.go(this, {
        duration: this.heroDuration,
        easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
      });

      transitions.forEach(function(transition) {
        transition.t.go(transition.t.el, transition.t.args);
      });
    },

    setupTransition: function(transitions, el) {
      var t = el.getAttribute('transition');
      var tt = this.getTransition(t);
      if (tt) {
        transitions.push({
          t: tt,
          el: el
        });
      }
    },

    complete: function() {
      this.transitioning.forEach(function(t) {
        t.removeAttribute('animate');
      });
      this.transitioning = [];

      this.fire('core-animated-pages-transition-end');
    },
    
    transitionEnd: function(e) {
      if (this.transitioning.length && this.selectedItem.contains(e.target) &&
          (e.propertyName === '-webkit-transform' || this._heroes.length === 0)) {
        this.job('transitionWatch', function() {
          this.complete();
        }, 500);
      }
    },

    selectedItemChanged: function(oldItem) {
      this.super(arguments);

      if (oldItem && this.selectedItem) {
        this.applyTransition(oldItem, this.selectedItem);
      }
    }

  });

</script>

</polymer-element>
