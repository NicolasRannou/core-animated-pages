<link href="../polymer/polymer.html" rel="import">
<link href="../core-selector/core-selector.html" rel="import">

<link href="transitions/hero-transition.html" rel="import">
<link href="transitions/cross-fade.html" rel="import">

<!--

`core-animated-pages` selects one of its children "pages" to show and runs a transition
when switching between them.

-->
<polymer-element name="core-animated-pages" extends="core-selector" notap attributes="transitions">

<template>

  <link href="core-animated-pages.css" rel="stylesheet">

  <shadow></shadow>

</template>

<script>

  Polymer({

    eventDelegates: {
      'core-transitionend': 'transitionEnd',
      'webkitTransitionEnd': 'transitionEnd',
      'transitionEnd': 'transitionEnd'
    },

    selected: 0,
    lastSelectedItem: null,

    registerCallback: function() {
      this.meta = document.createElement('core-transition');
    },

    created: function() {
      this._transitions = [];
      this.transitioning = [];
    },

    ready: function() {
      this.super(arguments);
    },

    transitionsChanged: function() {
      this._transitions = this.transitions.split(',');
    },

    _transitionsChanged: function(old) {
      if (old) {
        old.forEach(function(oldId) {
          var t = this.getTransition(oldId);
          if (t) {
            t.teardown(this);
          }
        }.bind(this));
      }
    },

    getTransition: function(transitionId) {
      return this.meta.byId(transitionId);
    },

    selectionSelect: function(e, detail) {
      this.updateSelectedItem();
      // Wait to call applySelection when we run the transition
    },

    applyTransition: function(src, dst) {
      if (this.transitioning.indexOf(src) === -1) {
        this.transitioning.push(src);
      }
      if (this.transitioning.indexOf(dst) === -1) {
        this.transitioning.push(dst);
      }

      var transitions = [];

      this._transitions.forEach(function(transitionId) {
        var t = this.getTransition(transitionId);
        if (t) {
          t.setup(src, dst, this);
          transitions.push(t);
        }
      }.bind(this));

      src.setAttribute('animate', '');
      dst.setAttribute('animate', '');

      getComputedStyle(src).top;

      this.applySelection(src, false);
      this.applySelection(dst, true);

      transitions.forEach(function(transition) {
        transition.go(this, {
          duration: 1000,
          easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
        });
      }.bind(this));
    },

    complete: function() {
      this.transitioning.forEach(function(t) {
        t.removeAttribute('animate');
      });
      this.transitioning = [];

      this.fire('core-animated-pages-transition-end');
    },
    
    transitionEnd: function(e) {
      if (this.transitioning.length && this.selectedItem.contains(e.target)) {
        this.job('transitionWatch', function() {
          this.complete();
        }, 500);
      }
    },

    selectedItemChanged: function(oldItem) {
      this.super(arguments);

      if (!oldItem) {
        this.applySelection(this.selectedItem, true);
      }

      if (oldItem && this.selectedItem) {
        // TODO(sorvell): allow bindings to update first?
        var self = this;
        Platform.endOfMicrotask(function() {
          self.applyTransition(oldItem, self.selectedItem);
        });
      }
    }

  });

</script>

</polymer-element>
