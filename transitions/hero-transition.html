<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link href="core-transition-pages.html" rel="import">

<core-style id="hero-transition">
  /* Hide heroes that are not currently transitioning */
  polyfill-next-selector { content: ':host > [animate] [hero]'; }
  ::content > [animate] /deep/ [hero] {
    visibility: hidden;
  }

  polyfill-next-selector { content: ':host > .core-selected [hero]'; }
  ::content > .core-selected[animate] /deep/ [hero] {
    visibility: visible;
    z-index: 10000;
  }
</core-style>


<polymer-element name="hero-transition" extends="core-transition-pages">
<script>
(function() {

  var webkitStyles = '-webkit-transition' in document.documentElement.style
  var TRANSITION_CSSNAME = webkitStyles ? '-webkit-transition' : 'transition';
  var TRANSFORM_CSSNAME = webkitStyles ? '-webkit-transform' : 'transform';
  var TRANSITION_NAME = webkitStyles ? 'webkitTransition' : 'transition';
  var TRANSFORM_NAME = webkitStyles ? 'webkitTransform' : 'transform';

  Polymer({

    go: function(scope, timing) {
      var props = [
        'border-radius',
        'width',
        'height',
        TRANSFORM_CSSNAME
      ];

      var duration = timing && timing.duration || 
          (CoreStyle.g.transitions.heroDuration || 
          CoreStyle.g.transitions.duration);

      scope._heroes.forEach(function(h) {
        var wt = [];
        props.forEach(function(p) {
          wt.push(p + ' ' + duration + ' ' + timing.easing);
        });

        h.h1.style[TRANSITION_NAME] = wt.join(', ');
        h.h1.style.borderRadius = h.r1;
        h.h1.style[TRANSFORM_NAME] = 'none';
      });
    },

    setup: function(src, dst, scope) {
      this.super(arguments);

      if (scope._heroes && scope._heroes.length) {
        this.teardown(scope);
      } else {
        scope._heroes = [];
      }

      // FIXME(yvonne): basic support for nested pages.
      // Look for heroes in the light DOM and one level of shadow DOM of the src and dst,
      // and also in src.selectedItem or dst.selectedItem, then transform the dst hero to src
      var ss = window.ShadowDOMPolyfill ? '[hero]' : '[hero], ::shadow [hero]';
      var h$ = src.querySelectorAll(ss);
      if (src.selectedItem) {
        h$ = h$.array();
        hs$ = src.selectedItem.querySelectorAll(ss);
        hsa$ = [];
        // De-duplicate items
        Array.prototype.forEach.call(hs$, function(hs) {
          if (h$.indexOf(hs) === -1) {
            hsa$.push(hs);
          }
        })
        h$ = h$.concat(hsa$);
      }

      for (var i=0, h0; h0=h$[i]; i++) {
        var v = h0.getAttribute('hero-id');
        var ds1 = '[hero][hero-id="' + v + '"]';
        var ds2 = '::shadow [hero][hero-id="' + v + '"]';
        var h1 = dst.querySelector(ds1) || (!window.ShadowDOMPolyfill && dst.querySelector(ds2));
        if (!h1 && dst.selectedItem) {
          h1 = dst.selectedItem.querySelector(ds1) || dst.selectedItem.querySelector(ds2);
        }

        // console.log(v, h0, h1);

        if (v && h1) {
          var c0 = getComputedStyle(h0);
          var c1 = getComputedStyle(h1);
          var h = {
            h0: h0,
            b0: h0.getBoundingClientRect(),
            r0: c0.borderRadius,
            h1: h1,
            b1: h1.getBoundingClientRect(),
            r1: c1.borderRadius
          };

          var dl = h.b0.left - h.b1.left;
          var dt = h.b0.top - h.b1.top;
          var sw = h.b0.width / h.b1.width;
          var sh = h.b0.height / h.b1.height;

          // h.scaley = h.h0.hasAttribute('scaley');
          // if (!h.scaley && (sw !== 1 || sh !== 1)) {
          //   sw = sh = 1;
          //   h.h1.style.width = h.b0.width + 'px';
          //   h.h1.style.height = h.b0.height + 'px';
          // }

          // Also animate the border-radius for the circle-to-square transition
          if (h.r0 !== h.r1) {
            h.h1.style.borderRadius = h.r0;
          }

          // console.log(h);

          h.h1.style[TRANSFORM_NAME] = 'translate(' + dl + 'px,' + dt + 'px)' + ' scale(' + sw + ',' + sh + ')';
          h.h1.style[TRANSFORM_NAME + 'Origin'] = '0 0';

          scope._heroes.push(h);
        }
      }

    },

    teardown: function(scope) {
      this.super(arguments);

      scope._heroes.forEach(function(h) {
        h.h1.style[TRANSITION_NAME] = null;
        h.h1.style[TRANSFORM_NAME] = null;
      });
      scope._heroes = [];
    },

    complete: function(scope, e) {
      if (e.propertyName === TRANSFORM_CSSNAME) {
        var done = true;
        scope._heroes.forEach(function(h) {
          if (h.h1 === e.path[0]) {
            h.complete = true;
          }
          if (!h.complete) {
            done = false;
          }
        });

        if (done) {
          this.teardown(scope);
          this.fire('core-transitionend', this, scope);
        }
      }
    }

  });

})();
</script>
</polymer-element>

<hero-transition id="hero-transition"></hero-transition>
